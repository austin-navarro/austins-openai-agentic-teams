[Skip to content](https://openai.github.io/openai-agents-python/ref/result/#results)

# `Results`

### RunResultBase`dataclass`

Bases: `ABC`

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>``` | ```md-code__content<br>@dataclass<br>class RunResultBase(abc.ABC):<br>    input: str | list[TResponseInputItem]<br>    """The original input items i.e. the items before run() was called. This may be a mutated<br>    version of the input, if there are handoff input filters that mutate the input.<br>    """<br>    new_items: list[RunItem]<br>    """The new items generated during the agent run. These include things like new messages, tool<br>    calls and their outputs, etc.<br>    """<br>    raw_responses: list[ModelResponse]<br>    """The raw LLM responses generated by the model during the agent run."""<br>    final_output: Any<br>    """The output of the last agent."""<br>    input_guardrail_results: list[InputGuardrailResult]<br>    """Guardrail results for the input messages."""<br>    output_guardrail_results: list[OutputGuardrailResult]<br>    """Guardrail results for the final output of the agent."""<br>    @property<br>    @abc.abstractmethod<br>    def last_agent(self) -> Agent[Any]:<br>        """The last agent that was run."""<br>    def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>        """A convenience method to cast the final output to a specific type. By default, the cast<br>        is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>        TypeError if the final output is not of the given type.<br>        Args:<br>            cls: The type to cast the final output to.<br>            raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>                the given type.<br>        Returns:<br>            The final output casted to the given type.<br>        """<br>        if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>            raise TypeError(f"Final output is not of type {cls.__name__}")<br>        return cast(T, self.final_output)<br>    def to_input_list(self) -> list[TResponseInputItem]:<br>        """Creates a new input list, merging the original input with all the new items generated."""<br>        original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>        new_items = [item.to_input_item() for item in self.new_items]<br>        return original_items + new_items<br>``` |

#### input`instance-attribute`

```md-code__content
input: str | list[TResponseInputItem]

```

The original input items i.e. the items before run() was called. This may be a mutated
version of the input, if there are handoff input filters that mutate the input.

#### new\_items`instance-attribute`

```md-code__content
new_items: list[RunItem]

```

The new items generated during the agent run. These include things like new messages, tool
calls and their outputs, etc.

#### raw\_responses`instance-attribute`

```md-code__content
raw_responses: list[ModelResponse]

```

The raw LLM responses generated by the model during the agent run.

#### final\_output`instance-attribute`

```md-code__content
final_output: Any

```

The output of the last agent.

#### input\_guardrail\_results`instance-attribute`

```md-code__content
input_guardrail_results: list[InputGuardrailResult]

```

Guardrail results for the input messages.

#### output\_guardrail\_results`instance-attribute`

```md-code__content
output_guardrail_results: list[OutputGuardrailResult]

```

Guardrail results for the final output of the agent.

#### last\_agent`abstractmethod``property`

```md-code__content
last_agent: Agent[Any]

```

The last agent that was run.

#### final\_output\_as

```md-code__content
final_output_as(
    cls: type[T], raise_if_incorrect_type: bool = False
) -> T

```

A convenience method to cast the final output to a specific type. By default, the cast
is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a
TypeError if the final output is not of the given type.

Parameters:

| Name | Type | Description | Default |
| --- | --- | --- | --- |
| `cls` | `type[T]` | The type to cast the final output to. | _required_ |
| `raise_if_incorrect_type` | `bool` | If True, we'll raise a TypeError if the final output is not of<br>the given type. | `False` |

Returns:

| Type | Description |
| --- | --- |
| `T` | The final output casted to the given type. |

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>``` | ```md-code__content<br>def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>    """A convenience method to cast the final output to a specific type. By default, the cast<br>    is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>    TypeError if the final output is not of the given type.<br>    Args:<br>        cls: The type to cast the final output to.<br>        raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>            the given type.<br>    Returns:<br>        The final output casted to the given type.<br>    """<br>    if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>        raise TypeError(f"Final output is not of type {cls.__name__}")<br>    return cast(T, self.final_output)<br>``` |

#### to\_input\_list

```md-code__content
to_input_list() -> list[TResponseInputItem]

```

Creates a new input list, merging the original input with all the new items generated.

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br>76<br>77<br>78<br>79<br>80<br>81<br>``` | ```md-code__content<br>def to_input_list(self) -> list[TResponseInputItem]:<br>    """Creates a new input list, merging the original input with all the new items generated."""<br>    original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>    new_items = [item.to_input_item() for item in self.new_items]<br>    return original_items + new_items<br>``` |

### RunResult`dataclass`

Bases: `RunResultBase`

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>``` | ```md-code__content<br>@dataclass<br>class RunResult(RunResultBase):<br>    _last_agent: Agent[Any]<br>    @property<br>    def last_agent(self) -> Agent[Any]:<br>        """The last agent that was run."""<br>        return self._last_agent<br>    def __str__(self) -> str:<br>        return pretty_print_result(self)<br>``` |

#### last\_agent`property`

```md-code__content
last_agent: Agent[Any]

```

The last agent that was run.

### RunResultStreaming`dataclass`

Bases: `RunResultBase`

The result of an agent run in streaming mode. You can use the `stream_events` method to
receive semantic events as they are generated.

The streaming method will raise:
\- A MaxTurnsExceeded exception if the agent exceeds the max\_turns limit.
\- A GuardrailTripwireTriggered exception if a guardrail is tripped.

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>``` | ```md-code__content<br>@dataclass<br>class RunResultStreaming(RunResultBase):<br>    """The result of an agent run in streaming mode. You can use the `stream_events` method to<br>    receive semantic events as they are generated.<br>    The streaming method will raise:<br>    - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>    - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>    """<br>    current_agent: Agent[Any]<br>    """The current agent that is running."""<br>    current_turn: int<br>    """The current turn number."""<br>    max_turns: int<br>    """The maximum number of turns the agent can run for."""<br>    final_output: Any<br>    """The final output of the agent. This is None until the agent has finished running."""<br>    _current_agent_output_schema: AgentOutputSchema | None = field(repr=False)<br>    _trace: Trace | None = field(repr=False)<br>    is_complete: bool = False<br>    """Whether the agent has finished running."""<br>    # Queues that the background run_loop writes to<br>    _event_queue: asyncio.Queue[StreamEvent | QueueCompleteSentinel] = field(<br>        default_factory=asyncio.Queue, repr=False<br>    )<br>    _input_guardrail_queue: asyncio.Queue[InputGuardrailResult] = field(<br>        default_factory=asyncio.Queue, repr=False<br>    )<br>    # Store the asyncio tasks that we're waiting on<br>    _run_impl_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _input_guardrails_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _output_guardrails_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _stored_exception: Exception | None = field(default=None, repr=False)<br>    @property<br>    def last_agent(self) -> Agent[Any]:<br>        """The last agent that was run. Updates as the agent run progresses, so the true last agent<br>        is only available after the agent run is complete.<br>        """<br>        return self.current_agent<br>    async def stream_events(self) -> AsyncIterator[StreamEvent]:<br>        """Stream deltas for new items as they are generated. We're using the types from the<br>        OpenAI Responses API, so these are semantic events: each event has a `type` field that<br>        describes the type of the event, along with the data for that event.<br>        This will raise:<br>        - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>        - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>        """<br>        while True:<br>            self._check_errors()<br>            if self._stored_exception:<br>                logger.debug("Breaking due to stored exception")<br>                self.is_complete = True<br>                break<br>            if self.is_complete and self._event_queue.empty():<br>                break<br>            try:<br>                item = await self._event_queue.get()<br>            except asyncio.CancelledError:<br>                break<br>            if isinstance(item, QueueCompleteSentinel):<br>                self._event_queue.task_done()<br>                # Check for errors, in case the queue was completed due to an exception<br>                self._check_errors()<br>                break<br>            yield item<br>            self._event_queue.task_done()<br>        if self._trace:<br>            self._trace.finish(reset_current=True)<br>        self._cleanup_tasks()<br>        if self._stored_exception:<br>            raise self._stored_exception<br>    def _check_errors(self):<br>        if self.current_turn > self.max_turns:<br>            self._stored_exception = MaxTurnsExceeded(f"Max turns ({self.max_turns}) exceeded")<br>        # Fetch all the completed guardrail results from the queue and raise if needed<br>        while not self._input_guardrail_queue.empty():<br>            guardrail_result = self._input_guardrail_queue.get_nowait()<br>            if guardrail_result.output.tripwire_triggered:<br>                self._stored_exception = InputGuardrailTripwireTriggered(guardrail_result)<br>        # Check the tasks for any exceptions<br>        if self._run_impl_task and self._run_impl_task.done():<br>            exc = self._run_impl_task.exception()<br>            if exc and isinstance(exc, Exception):<br>                self._stored_exception = exc<br>        if self._input_guardrails_task and self._input_guardrails_task.done():<br>            exc = self._input_guardrails_task.exception()<br>            if exc and isinstance(exc, Exception):<br>                self._stored_exception = exc<br>        if self._output_guardrails_task and self._output_guardrails_task.done():<br>            exc = self._output_guardrails_task.exception()<br>            if exc and isinstance(exc, Exception):<br>                self._stored_exception = exc<br>    def _cleanup_tasks(self):<br>        if self._run_impl_task and not self._run_impl_task.done():<br>            self._run_impl_task.cancel()<br>        if self._input_guardrails_task and not self._input_guardrails_task.done():<br>            self._input_guardrails_task.cancel()<br>        if self._output_guardrails_task and not self._output_guardrails_task.done():<br>            self._output_guardrails_task.cancel()<br>    def __str__(self) -> str:<br>        return pretty_print_run_result_streaming(self)<br>``` |

#### current\_agent`instance-attribute`

```md-code__content
current_agent: Agent[Any]

```

The current agent that is running.

#### current\_turn`instance-attribute`

```md-code__content
current_turn: int

```

The current turn number.

#### max\_turns`instance-attribute`

```md-code__content
max_turns: int

```

The maximum number of turns the agent can run for.

#### final\_output`instance-attribute`

```md-code__content
final_output: Any

```

The final output of the agent. This is None until the agent has finished running.

#### is\_complete`class-attribute``instance-attribute`

```md-code__content
is_complete: bool = False

```

Whether the agent has finished running.

#### last\_agent`property`

```md-code__content
last_agent: Agent[Any]

```

The last agent that was run. Updates as the agent run progresses, so the true last agent
is only available after the agent run is complete.

#### stream\_events`async`

```md-code__content
stream_events() -> AsyncIterator[StreamEvent]

```

Stream deltas for new items as they are generated. We're using the types from the
OpenAI Responses API, so these are semantic events: each event has a `type` field that
describes the type of the event, along with the data for that event.

This will raise:
\- A MaxTurnsExceeded exception if the agent exceeds the max\_turns limit.
\- A GuardrailTripwireTriggered exception if a guardrail is tripped.

Source code in `src/agents/result.py`

|     |     |
| --- | --- |
| ```<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>``` | ```md-code__content<br>async def stream_events(self) -> AsyncIterator[StreamEvent]:<br>    """Stream deltas for new items as they are generated. We're using the types from the<br>    OpenAI Responses API, so these are semantic events: each event has a `type` field that<br>    describes the type of the event, along with the data for that event.<br>    This will raise:<br>    - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>    - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>    """<br>    while True:<br>        self._check_errors()<br>        if self._stored_exception:<br>            logger.debug("Breaking due to stored exception")<br>            self.is_complete = True<br>            break<br>        if self.is_complete and self._event_queue.empty():<br>            break<br>        try:<br>            item = await self._event_queue.get()<br>        except asyncio.CancelledError:<br>            break<br>        if isinstance(item, QueueCompleteSentinel):<br>            self._event_queue.task_done()<br>            # Check for errors, in case the queue was completed due to an exception<br>            self._check_errors()<br>            break<br>        yield item<br>        self._event_queue.task_done()<br>    if self._trace:<br>        self._trace.finish(reset_current=True)<br>    self._cleanup_tasks()<br>    if self._stored_exception:<br>        raise self._stored_exception<br>``` |